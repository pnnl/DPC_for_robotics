import numpy as np
import mediapy as media
import mujoco as mj
import os
import matplotlib.pyplot as plt

xml_path = "mujoco/quadrotor_x.xml"
write_path = "media/mujoco/"
d2r = np.pi / 180

# get the full path
dirname = os.path.dirname(__file__)
abspath = os.path.join(dirname + "/" + xml_path)
xml_path = abspath

# MuJoCo data structures
model = mj.MjModel.from_xml_path(xml_path)  # MuJoCo model

# model geometry names
geom_names = [
    "arm_back0",
    "arm_front0",
    "arm_left0",
    "arm_right0",
    "core_geom",
    "floor",
]

# model body names
body_names = [
    "arm_back1",
    "arm_front1",
    "arm_left1",
    "arm_right1",
    "core",
    "thruster0",
    "thruster1",
    "thruster2",
    "thruster3",
    "world",
]

# mjdata constains the state and quantities that depend on it.
data = mj.MjData(model)

# the state is made up of time, generalised positions and velocities
time = data.time
qpos = data.qpos
qvel = data.qvel

# we can also retrieve cartesian coordinates, however this is zeros until
# the simulation is propogated once
xpos = data.geom_xpos

# propogate the simulation to get non generalised state data with minimal function
mj.mj_kinematics(model, data)

# MjData also supports named access:
# arm_front0_xpos = data.geom('arm_front0').xpos

# Make renderer, render and show the pixels
# model.vis.scale.framelength *= 10
# model.vis.scale.framewidth *= 10
renderer = mj.Renderer(model=model, height=720, width=1280)

# the image will still be black
image = renderer.render()
media.write_image(write_path + "image.png", image)

# the minimal function doesnt invoke entire pipeline so a rendered image will
# still be black as if no dynamics propogated, therefore use full mj_forward
mj.mj_forward(model, data)
renderer.update_scene(data)

# now we will get an image of the scene
media.write_image(write_path + "image.png", renderer.render())

### lets simulate and render a video
duration = 3.8  # (seconds)
framerate = 60  # (Hz)

# Simulate and display video.
frames = []
qpos_data = []
qvel_data = []
mj.mj_resetData(model, data)  # Reset state and time.
data.ctrl = [0.0, 0.0, 0.0, 0.0]
while data.time < duration:
    # kTh * w_hover ** 2 = 2.943
    data.ctrl = [2.943]*4
    data.ctrl[0] = 1.076e-5*(523.3)**2 # take one motor to 80 % causing a crash
    # data.ctrl = [3]*4
    mj.mj_step(model, data)
    qpos_data.append(data.qpos.copy()) # copy is necessary otherwise it'll be overwritten
    qvel_data.append(data.qvel.copy())
    if len(frames) < data.time * framerate:

        renderer.update_scene(data)
        pixels = renderer.render()
        frames.append(pixels)
media.write_video(write_path + "video.mp4", frames, fps=framerate)

# def mjstate2mpcstate(mjstate):
#     mpcstate = mjstate.copy()
#     flipped_state_idx = [1,2,5,8,9,11]
#     mpcstate[:,flipped_state_idx] *= -1
#     return mpcstate

# Convert list of arrays to 2D array
qpos_data = np.vstack(qpos_data)
qvel_data = np.vstack(qvel_data)

qpos_data[:,1] *= -1
qpos_data[:,2] *= -1
qpos_data[:,5] *= -1

qvel_data[:,1] *= -1
qvel_data[:,2] *= -1
qvel_data[:,4] *= -1


# List of labels
qpos_labels = ['x', 'y', 'z', 'q0', 'q1', 'q2', 'q3']
qvel_labels = ['xdot', 'ydot', 'zdot', 'p', 'q', 'r']

# Create subplots for qpos_data
plt.figure(figsize=(5, 8)) # Adjust the figure size as needed
for i in range(7):
    plt.subplot(7, 1, i + 1)
    plt.plot(qpos_data[:, i])
    plt.ylabel(qpos_labels[i])

plt.xlabel('Time step')
plt.suptitle('QPos over time')
plt.tight_layout(rect=[0, 0, 1, 0.96]) # To make sure the title doesn't overlap

# Create subplots for qvel_data
plt.figure(figsize=(5, 8)) # Adjust the figure size as needed
for i in range(6):
    plt.subplot(6, 1, i + 1)
    plt.plot(qvel_data[:, i])
    plt.ylabel(qvel_labels[i])

plt.xlabel('Time step')
plt.suptitle('QVel over time')
plt.tight_layout(rect=[0, 0, 1, 0.96]) # To make sure the title doesn't overlap

plt.show()

# for the python simulation we need the moments of inertia of the mujoco simulation
I = np.zeros([3, 3])
# this iterates through the inertias generated by the point masses in body_inertia
for inertia in model.body_inertia:
    I += np.diag(inertia)

print(f"This is I: {I}")

# TODO: calculate tau properly
# tau = np.array([L*k*(omega1**2 - omega3**2),
#                 L*k*(omega2**2 - omega4**2),
#                 b*(omega1**2-omega2**2+omega3**2-omega4**2)])
tau = np.array([0, 0, 0.01])  # torque vector in body frame

w = np.array([0.1, 0.1, 0.1])  # angular velocities p,q,r in body frame

phi = d2r * 10
theta = d2r * -45

# rotational dynamics
p, q, r = np.linalg.inv(I) @ (tau - np.cross(w, I @ w))  # in bodyframe

# euler angles
body2world = np.array(
    [
        [1, np.sin(phi) * np.tan(theta), np.cos(phi) * np.tan(theta)],
        [0, np.cos(phi), -np.sin(phi)],
        [0, np.sin(phi) / np.cos(theta), np.cos(phi) / np.cos(theta)],
    ]
)
phidot, thetadot, psidot = body2world @ np.array([p, q, r])  # [:,None]

# translational dynamics
# x2dot =

# lets get the rotor inertia
# m = model.body("thruster0").mass
r = 0.05

print(model)
